

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Small files &mdash; Aalto scientific computing</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/theme_overrides.css" type="text/css" />
  

  
    <link rel="top" title="Aalto scientific computing" href="../../index.html"/>
        <link rel="up" title="Triton user guide" href="../index.html"/>
        <link rel="next" title="Storage" href="storage.html"/>
        <link rel="prev" title="Singularity Containers" href="singularity.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Aalto scientific computing
          

          
            
            <img src="../../_static/aalto.png" class="logo" />
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../aalto/welcomeresearchers.html">Welcome, researchers!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../aalto/welcomestudents.html">Welcome, students!</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../news/index.html">News</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../aalto/index.html">The Aalto environment</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../data/index.html">Data</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Triton user guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../index.html#quick-contents-and-links">Quick contents and links</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#tutorials">Tutorials</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html#detailed-instructions">Detailed instructions</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="compilers.html">Available compilers</a></li>
<li class="toctree-l3"><a class="reference internal" href="debugging.html">Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="dgx.html">Nvidia DGX machines</a></li>
<li class="toctree-l3"><a class="reference internal" href="faq.html">Frequently asked questions</a></li>
<li class="toctree-l3"><a class="reference internal" href="general.html">Running programs on Triton</a></li>
<li class="toctree-l3"><a class="reference internal" href="gpu.html">GPU Computing</a></li>
<li class="toctree-l3"><a class="reference internal" href="grid.html">Grid computing</a></li>
<li class="toctree-l3"><a class="reference internal" href="grid2.html">Grid computing 2</a></li>
<li class="toctree-l3"><a class="reference internal" href="jobs.html">Monitoring jobs</a></li>
<li class="toctree-l3"><a class="reference internal" href="libs.html">Libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="localstorage.html">Storage: local drives</a></li>
<li class="toctree-l3"><a class="reference internal" href="lustre.html">Storage: Lustre (scratch)</a></li>
<li class="toctree-l3"><a class="reference internal" href="mpilibs.html">MPI on Triton</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="quotas.html">Quotas</a></li>
<li class="toctree-l3"><a class="reference internal" href="singularity.html">Singularity Containers</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">Small files</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contents">Contents</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-problem-with-small-files">The problem with small files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#why-do-people-make-millions-of-small-files">Why do people make millions of small files?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strategies">Strategies</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specific-example-hdf5-for-numerical-data-or-some-database">Specific example: HDF5 for numerical data, or some database</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specific-example-unpacking-to-local-disk">Specific example: Unpacking to local disk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#specific-example-key-value-stores">Specific example: Key-value stores</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performance-tuning-for-small-files">Performance tuning for small files</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="storage.html">Storage</a></li>
<li class="toctree-l3"><a class="reference internal" href="toolchains.html">Compilers and toolchains</a></li>
<li class="toctree-l3"><a class="reference internal" href="workflows.html">Remote workflows at Aalto</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#applications">Applications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index.html#reference-and-examples">Reference and Examples</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../scicomp/index.html">Scientific computing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../training/index.html">Training</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">About these docs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">Aalto scientific computing</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Triton user guide</a> &raquo;</li>
      
    <li>Small files</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="https://github.com/AaltoScienceIT/scicomp-docs/blob/master/triton/usage/smallfiles.rst" class="fa fa-github"> Edit on GitHub</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="small-files">
<h1>Small files<a class="headerlink" href="#small-files" title="Permalink to this headline">¶</a></h1>
<p>Millions of small files are a huge problem on any filesystem.  You may
think /scratch, being a fast filesystem, doesn&#8217;t have this problem, but
it&#8217;s actually worse here.  Lustre (scratch) as like an object store, and
stores files separately from medatata.  This means that each file access
requires multiple different network requests, and making a lot of files
brings your research (and managing the cluster) to a halt.  What counts
as a lot?  Your default quota is 1e6 files.  1e4 for a project is not a
lot.  1e6 for a single project is.</p>
<p>You may have been directed here because you have a lot of files.  In
that case, welcome to the world of big data, even if your total size
isn&#8217;t that much!  (it&#8217;s not just size, but difficulty of handling using
normal tools)  Please read this and see what you can learn, and ask us
if you need help.</p>
<p>This page is mostly done, but specific examples could be expanded.</p>
<p>See also:</p>
<ul class="simple">
<li><a class="reference internal" href="lustre.html"><em>Data storage on the Lustre file
system</em></a>,
especially the bottom.</li>
<li><a class="reference internal" href="localstorage.html"><em>Compute node local drives</em></a></li>
</ul>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="the-problem-with-small-files">
<h2>The problem with small files<a class="headerlink" href="#the-problem-with-small-files" title="Permalink to this headline">¶</a></h2>
<p>You know Lustre is high performance and fast.  But, there is a
relatively high overhead for accessing each file.  Below, you can see
some sample transfer rates, and you can see that total performance drops
drastically when files get small.  (These numbers were for the pre-2016
Lustre system, it&#8217;s better now but the same principle applies.)  This
isn&#8217;t just a problem when you are trying to read files, it&#8217;s also a
problem when managing, moving, migrating, etc.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">File size</th>
<th class="head">Net transfer rate, many files of this size</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>10GB</td>
<td>1100 MB/s</td>
</tr>
<tr class="row-odd"><td>100MB</td>
<td>990 MB/s</td>
</tr>
<tr class="row-even"><td>1MB</td>
<td>90MB/s</td>
</tr>
<tr class="row-odd"><td>10KB</td>
<td>.9MB/s</td>
</tr>
<tr class="row-even"><td>512B</td>
<td>.04 MB/s</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="why-do-people-make-millions-of-small-files">
<h2>Why do people make millions of small files?<a class="headerlink" href="#why-do-people-make-millions-of-small-files" title="Permalink to this headline">¶</a></h2>
<p>We understand there reasons people make lots of files: it&#8217;s convenient.
Here are some of the common problems (and alternative solutions) people
may be trying to solve with lots of files.</p>
<ul class="simple">
<li>Flat files are universal format. If you have everything in its own
file, then any other program can look at any data individually.  It&#8217;s
convenient.  This is a fast way to get started and use things.</li>
<li>Compatibility with other programs.  Same as above.</li>
<li>Ability to use standard unix shell tools.  Maybe your whole
preprocessing pipeline is putting each piece of data in its own file
and running different standard programs on it.  It&#8217;s the Unix way,
after all.
Using filesystem as your index.  Let&#8217;s say you have a program that
reads/writes data which is selected by different keys.  It needs to
locate the data for each key separately.  It&#8217;s convenient to put all
of these in their own files: this takes the role of a database index,
and you simply open the file with the name of the key you need.  But
the filesystem is <em>not</em> a good index.<ul>
<li>Once you get too many files, a database is the right tool for the
job.  There are databases which operate as single files, so it&#8217;s
actually very easy.</li>
</ul>
</li>
<li>Concurrency: you use filesystem as the concurrency layer.  You submit
a bunch of jobs, each job writes data to its own file.  Thus, you
don&#8217;t have to worry about problems with appending to the same
file/database synchronization/locking/etc.  This is actually a very
common reason.<ul>
<li>This is a big one.  The filesystem is the most reliable way to
join the output of different jobs (for example an array job), and
it&#8217;s hard to find a better strategy.  It&#8217;s reasonable to keep
doing this, and combine job outputs in a second stage to reduce
the number of files</li>
</ul>
</li>
<li>Safety/security: the filesystem isolates different files from each
other, so if you modify one, there&#8217;s less chance of corrupting any
other ones.  This goes right along with the reason above.</li>
<li>You only access a few files at a time in your day to day work, so you
never realize there&#8217;s a problem.  However, when we try to manage data
(migrate, move, etc), then a problem comes up.</li>
<li>Realize that forking processes has similar overhead. Small reads are
also non-ideal, but less bad(?).</li>
</ul>
</div>
<div class="section" id="strategies">
<h2>Strategies<a class="headerlink" href="#strategies" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Realize you will have to have to change you workflow. You can&#8217;t do
everything with grep, sort, wc, etc. anymore. Congratulations, you
have big data.</li>
<li>Consider right strategy for your program: a serious program should
provide options for this.<ul>
<li>For example, I&#8217;ve seen some machine learning frameworks which
provide an option to compress all the input data into a single
file that is optimized for reading.  This is precisely designed
for this type of case.  You <em>could</em> read all the files
individually, but it&#8217;ll be slower.  So in this case, one should
first read the documentation and see there&#8217;s a solution.  One
would take all the original files and make the processed input
files.  Then, take the original training data, package it together
in one compressed archive for long-term storage.  If you need to
look at individual input files, you can always decompress one by
one.</li>
</ul>
</li>
<li>Split - combine - analyze<ul>
<li>Continue like you have been doing: each (array?) job makes
different output files.   Then, after running, combine the outputs
into one file/database.  Clean up/archive the intermediate files.
Use this combined DB/file to analyze the data in the long term.
This is perhaps the easiest way to adapt your workflow.</li>
</ul>
</li>
<li>HDF5: especially for numerical data, this is a good format for
combining your results.  It is like a filesystem within a file, you
can still name your data based on different keys for individual
access.</li>
<li>Unpack to local disk, pack to scratch when done.<ul>
<li>Main article: <a class="reference internal" href="localstorage.html"><em>Compute node local
drives</em></a>,</li>
<li>This strategy can be combined with many of the other strategies
below</li>
<li>This strategy is especially good when your data is
write-once-read-many.  You package all of your original data into
one convenient archive, and unpack it to the local disk when you
need it.  You delete it when you are done.</li>
</ul>
</li>
<li>Use a proper database suitable for your domain (sqlite): Storing lots
of small data where anything can be quickly findable and you can do
computation efficiently is exactly what databases do.  It can be
difficult to have a general purpose database work for you, but there
are a wide variety of special-purposes databases these days.  Could
one of them be suitable for storing the results of your computation
for analysis?<ul>
<li>Note that if you are really doing high-performance random IO,
putting a database on scratch is not a good idea, and you need to
think more.</li>
<li>Consider combining this with local disk: You can copy your
pre-created database file to local disk and do all the random
access you need.  Delete when done.  You can do
modification/changes directly on scratch if you want.</li>
</ul>
</li>
<li>key-value stores: A string key stores arbitrary data.<ul>
<li>This is a more general database, basically.  It stores arbitrary
data for a certain key.</li>
</ul>
</li>
<li>Read all data to memory.<ul>
<li>A strategy for using many files.  Combine all data into one file,
read them all into memory, then do the random access in memory.</li>
</ul>
</li>
<li>Compress them down when done.<ul>
<li>It&#8217;s pretty obvious: when you are done with files, compress all of
them into one.  You have the archive and can always unpack when
needed.  You should especially at least do this when you are done
with a project: if everyone did this, the biggest problems could
be solved.</li>
</ul>
</li>
<li>Make sure you have proper backups for large files, mutating files
introduces risks!<ul>
<li>If you do go using these strategies, make sure you don&#8217;t
accidentally lose something you need.  Have backups (even if it&#8217;s
on scratch: backup your database files)</li>
</ul>
</li>
<li>If you do have to keep many small flies, check the link above for
lustre performance tuning.<ul>
<li><a class="reference internal" href="lustre.html"><em>Data storage on the Lustre file
system</em></a></li>
</ul>
</li>
<li>If you have other programs that can only operate on separate files<ul>
<li>This is a tough situation, investigate what you can do combining
the strategies above.  At least you can pack up when done, and
possibly copying to local disk while you are accessing is a good
idea.</li>
</ul>
</li>
<li>MPI-I/O: if you are writing your own MPI programs, this can
parallelize output</li>
</ul>
</div>
<div class="section" id="specific-example-hdf5-for-numerical-data-or-some-database">
<h2>Specific example: HDF5 for numerical data, or some database<a class="headerlink" href="#specific-example-hdf5-for-numerical-data-or-some-database" title="Permalink to this headline">¶</a></h2>
<p>HDF5 is essentially a database for numerical data.  You open a HDF5 file
and access different data by path - the path is like a filename.  There
are libraries for accessing this data from all relevant programming
languages.</p>
<p>If you have some other data that is structured, there are other
databases that will work.  For example, sqlite is a single-file,
serverless database for relational data, and there are other similar
things for time serieses or graphs.</p>
</div>
<div class="section" id="specific-example-unpacking-to-local-disk">
<h2>Specific example: Unpacking to local disk<a class="headerlink" href="#specific-example-unpacking-to-local-disk" title="Permalink to this headline">¶</a></h2>
<p>You can see examples at <a class="reference internal" href="localstorage.html"><em>compute node local
drives</em></a></p>
</div>
<div class="section" id="specific-example-key-value-stores">
<h2>Specific example: Key-value stores<a class="headerlink" href="#specific-example-key-value-stores" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s say you have written all your own code and want an alternative to
files.  Instead, use a key-value database.  You open one file, and store
your file contents under different keys.  When you need the data out,
you request it by that key again.  The keys take the place of
filenames.  Anytime you would open files, you just access from these
key-value stores.  You also have ways of dumping and restoring the data
if you need to analyze it from different programs.</p>
</div>
<div class="section" id="performance-tuning-for-small-files">
<h2>Performance tuning for small files<a class="headerlink" href="#performance-tuning-for-small-files" title="Permalink to this headline">¶</a></h2>
<p>See here: <a class="reference internal" href="lustre.html"><em>Data storage on the Lustre file
system</em></a></p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="storage.html" class="btn btn-neutral float-right" title="Storage" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="singularity.html" class="btn btn-neutral" title="Singularity Containers" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Aalto Science-IT.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.


</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/redirect-to-https.js"></script>
      <script type="text/javascript" src="https://users.aalto.fi/~darstr1/minipres-stable.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>